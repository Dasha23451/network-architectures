<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Просмотр лекций</title>
    <style>
        /* Стилизация страницы */
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        .container {
            display: flex;
        }
        /* Стилизация бокового меню */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 220px;
            height: 100%;
            background-color: #2c3e50;
            padding-top: 20px;
        }
        .sidebar ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .sidebar li {
            margin-bottom: 15px;
        }
        .sidebar a {
            color: #ecf0f1;
            text-decoration: none;
            padding: 12px 20px;
            display: block;
        }
        .sidebar a:hover {
            background-color: #34495e;
        }
        /* Стилизация основного контента */
        .content {
            margin-left: 240px;
            padding: 20px;
            max-width: 1000px;
            min-width: 600px;
        }
        h1 {
            font-size: 28px;
            color: #2c3e50;
        }
        h2 {
            font-size: 22px;
            color: #34495e;
        }
        p, li {
            font-size: 16px;
            line-height: 1.6;
            color: #7f8c8d;
        }
        /* Стилизация для popup */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(44, 62, 80, 0.9);
        }
        .modal-content {
            background-color: #ecf0f1;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #2c3e50;
            width: 80%;
            max-width: 800px;
            position: relative;
        }
        .close {
            color: #2c3e50;
            position: absolute;
            top: 10px;
            right: 25px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        #lecture-content {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #lecture-content ul{
            width: 100%;
            align-items: start;
        }
        #lecture-content ol{
            width: 100%;
            align-items: start;
        }
        #lecture-content p{
            width: 100%;
        }
        /* Стилизация canvas */
        #popupCanvas {
            border: 2px solid #333;
            display: block;
            margin: 0 auto;
        }
        #moveButton {
            display: block;
            margin: 20px auto;
        }
        #explanation {
            text-align: center;
            margin-top: 20px;
            font-size: 18px;
            height: 24px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Боковое меню -->
        <nav class="sidebar">
            <ul>
                <li><a href="#" data-topic="topic1">Тема 1: Классификация сигналов</a></li>
                <li><a href="#" data-topic="topic2">Тема 2: Исследование частотных характеристик сигналов</a></li>
                <li><a href="#" data-topic="topic3">Тема 3: Продвинутые концепции</a></li>
                <li><a href="#" data-topic="topic4">Тема 4: Семиуровневая модель OSI</a></li>
                <li><a href="#" data-topic="topic5">Тема 5: Стек протокола TCP/IP</a></li>
                <li><a href="#" data-topic="topic6">Тема 6: Классификация ВС</a></li>
                <li><a href="#" data-topic="topic7">Тема 7: Сетевая топология</a></li>
            </ul>
        </nav>
        <!-- Основное содержание -->
        <main class="content">
            <div id="lecture-content">
                <!-- Лекция будет загружена сюда -->
            </div>
        </main>
    </div>
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <!-- Содержание popup -->
            <canvas id="popupCanvas" width="600" height="300"></canvas>
            <button id="moveButton">Переместить V</button>
            <div id="explanation"></div>
        </div>
    </div>
    <script>
        // Объект с содержанием лекций
        const topics = {
            topic1: {
                title: "Тема 1: Введение",
                content: `
                    <h1>Тема 1: Введение</h1>
                    <h2>Подзаголовок 1</h2>
                    <p>Добро пожаловать в первую лекцию курса! Здесь мы рассмотрим основные понятия и подготовимся к дальнейшему изучению.</p>
                    <button id="openPopup">Открыть интерактивное окно</button>
                `
            },
            topic2: {
                title: "Тема 2: Основы",
                content: `
                    <h1>Тема 2: Основы</h1>
                    <h2>Подзаголовок 1</h2>
                    <p>В этой лекции мы погрузимся в базовые концепции и термины, необходимые для понимания материала.</p>
                    <h2>Подзаголовок 2</h2>
                    <p>Рассмотрим ключевые принципы и их практическое применение.</p>
                `
            },
            topic3: {
                title: "Тема 3: Продвинутые концепции",
                content: `
                    <h1>Тема 3: Продвинутые концепции</h1>
                    <h2>Подзаголовок 1</h2>
                    <p>Изучим более сложные темы и углубимся в детали.</p>
                    <h2>Подзаголовок 2</h2>
                    <p>Разберём реальные кейсы и примеры использования.</p>
                `
            },
            topic4: {
                title: "Тема 4: Многоуровневые сетевые модели",
                content: `
                    <h1>Многоуровневые сетевые модели</h1>
                    <p>Глобальные сети объединяют в себе огромное количество географически распределённых узлов. Множество вариантов программно-технической реализации передачи информации породили необходимость создания открытых стандартов — стандартов, официально опубликованных и доступных для разработчиков программно-аппаратных компонентов.</p>
                    
                    <img src="./images/Одноуровневое_взаимодействие.gif">
                    
                    <h2>Взаимодействие уровней</h2>
                    <p>Взаимодействие приложений через сеть очень сложно. Разделение его на уровни позволяет понизть сложность. Каждый уровень взаимодействует через сеть с одноименным уровнем. Для этого уровень пользуется услугами нижележащего уровня и каждый уровень предоставляет услуги вышележащему уровню.</p>
                    <p>Благодаря такой структуре совместная работа сетевого оборудования и программного обеспечения становится гораздо проще и понятнее.</p>
                    
                    <img src="./images/Сетевая_модель.gif">
                    
                    <h2>Сетевая модель</h2>
                    <p>Сетевая модель определяет:</p>
                    <ul>
                    <li><b>службы</b> — то, что делается на данном уровне;</li>
                    <li><b>интерфейсы (API)</b> — как обращаться к другим уровням;</li>
                    <li><b>протоколы</b> — набор правил общения с одноуровневым компонентом на другом узле сети.</li>
                    </ul>
                    <h2>Как устроена сетевая модель</h2>
                    <p>Каждый сетевой уровень подчиняется определенному сетевому протоколу, определяющему набор сетевых служб, присущих данному уровню.</p>
                    <p><b>Сетевая служба</b> — это набор функций, которыми обладает определенный сетевой уровень, выполняемых для вышележащего уровня (например, коррекция ошибок).</p>
                    <p>Каждый сетевой уровень запрашивает определенную сетевую службу от нижележащего уровня. Протокол уровня определяет структуру данных и формат пакета для выполнения запрашиваемой сетевой службы.</p>
                    <p><b>Протокол</b> — это правила, которым должен следовать уровень, чтобы реализовать сетевую службу.</p>
                    <p>Сетевой протокол описывает формат данных или пакетов данных, то есть правила оформления, которым данные должны подчиняться, чтобы программное обеспечение выполняло ту или иную функцию или сетевую службу (для случая коррекции ошибок протокол описывает какие ошибки сетевая служба должна исправлять).</p>
                    <p>Пример. Почтовая служба. Чтобы отправить кому-либо письмо, мы пишем адрес на кон-верте. Таким образом, функция адреса заключается в обеспечении правильной доставки. Формат, в котором пишется адрес, строго определен: 1-я строка – кому, 2-я строка – улица, дом, 3-я строка – город. Почтовые работники ожидают, что на второй строке будет указана улица, а за ней – номер дома. Формат адреса на конверте следует определенному протоколу.</p>
                    <h3>Пример трехуровневой модели</h3>

                    <img src="./images/Пример_трехуровневой_модели.gif">

                    <p>Философы используют функции нижележащих уровней: переводчиков и почты. Они непосредственно общаются с переводчиками. Переводчики переводят сообщение, затем оно отправляется по почте.</p>
                    <h3>Передача сообщения</h3>
                    <p>При передаче, информация делится на пакеты. Фактически, передаваемая информация формируется на самом верхнем уровне — уровне работающего приложения (прикладном). Далее пакет «спускается» по уровням модели и на каждом из них получает свой заголовок и концевик. Этот заголовок содержит функционально-специфичную для данного уровня информацию о пакете (например, адрес). При получении информации узлом-получателем большой (с заголовками всех уровней) блок информации начинает обрабатываться в обратной, восходящей, последовательности уровней, причём на каждом уровне происходит анализ и отщепление соответствующего заголовка. Таким образом, до процесса-получателя доходит исходный передаваемый блок. На уровнях сообщение M вместе с заголовками от верхних уровней может подвергается изменениям: шифрованию, сжатию, разбиению на части,…, поэтому изображенная картинка с одной и той же часть M, вообще говоря, не совсем правильная (зато понятная).</p>
                    
                    <img src="./images/Передача_сообщения.gif">

                    <p>Пример. Вспомним беседу философов. Переводчик хинди-английский переводит исходное сообщение философа, дополнительно делая пометки о значениях слов. Далее, на почте это письмо запечатывается в конверт, на конверте пишется соответствующая информация (об отправителе и получателе). На почте в Голландии конверт распечатывается, и письмо передается переводчику английский-голландский. Используя сделанные коллегой пометки, переводчик восстанавливает на голландском содержимое письма. Письмо передается голландскому философу.</p>
                    <h2>Эталонная модель OSI</h2>
                    <p></p>
                    <p>Эталонная модель взаимодействия открытых систем, Open Systems Interconnection Reference Model (OSI), создавалась как единый международный стандарт сетевых технологий.</p>
                    <p>Набор протоколов называется открытым, если описание и детали протоколов опубликованы.</p>
                    <p>Система, реализующая открытые протоколы называется открытой системой, несмотря на то, что код программ может быть закрыт.</p>
                    <p>ISO — международная организация по стандартизации.</p>
                    <p>OSI ISO — абстрактная модель для сетевых коммуникаций и разработки сетевых протоколов. Представляет уровневый подход к сети. Каждый уровень обслуживает свою часть процесса взаимодействия. Благодаря такой структуре совместная работа сетевого оборудования и программного обеспечения становится гораздо проще и понятнее.</p>
                    <h2>Модель OSI</h2>
                    <p>Модель OSI имеет семиуровневую структуру, и можно говорить о взаимодействии узла-отправителя и узла-получателя на каждом уровне модели.</p>
                    <p>Функции уровней модели OSI могут быть разбиты на группы по критерию их зависимости от аппаратуры сети.</p>
                    <p><b>Три нижних уровня – физический, канальный и сетевой являются сетезависимыми. Их протоколы тесно связаны с аппаратным обеспечением.</b> Например, переход от сетевой технологии Token Ring к технологии Ethernet означает полную смену протоколов этих уровней.</p>
                    <p><b>Три верхних уровня – сеансовый, представления и прикладной – мало зависят от технической реализации сети. На протоколы этих уровней не влияют ни замена сетевых технологий, ни смена топологии сети.</b></p>
                    <p>Транспортный уровень занимает промежуточное положение. Он скрывает детали работы нижних уровней от верхних уровней.</p>
                    <h2>Функции уровней</h2>
                    <p>В компьютерной сети каждый уровень может выполнять одну или несколько функций, перечисленных ниже.</p>
                    <ul>
                    <li>адресация,</li>    
                    <li>правила переноса данных: направление переноса (например, только в одном направлении или в любом направлении), логические каналы (например, специальный канал для «срочных» данных),</li>
                    <li>контроль ошибок,</li>
                    <li>соблюдение последовательности пакетов,</li>
                    <li>управление потоком сообщений (быстрый не зафладит медленного),</li>
                    <li>мультиплексирование: объединение несвязанных пакетов для совместной передачи на одном из уровней (например, на физическом уровне мультиплексирование чаще всего неизбежно, так как вся связь осуществляется по ограниченному числу контуров)</li>
                    <li>маршрутизация.</li>    
                    </ul>
                    <h2>Взаимодействие уровней модели OS</h2>
                    <p>Модель OSI можно разделить на 2 различных модели, как показано на рис. 5 :</p>
                    <ul>
                    <li>горизонтальную модель на базе протоколов, обеспечивающую механизм взаимодействия программ и процессов на различных машинах;</li>    
                    <li>вертикальную модель на основе услуг, обеспечиваемых соседними уровнями друг другу на одной машине.</li>   
                    </ul>
                    <p>Каждый уровень компьютера-отправителя взаимодействует с таким же уровнем компьютера-получателя, как будто он связан напрямую. Такая связь называется логической или виртуальной связью. В действительности взаимодействие осуществляется между смежными уровнями одного компьютера.</p>
                    <p>Итак, информация на компьютере-отправителе должна пройти через все уровни. Затем она передается по физической среде до компьютера-получателя и опять проходит сквозь все слои, пока не доходит до того же уровня, с которого она была послана на компьютере-отправителе.</p>
                    <p>В горизонтальной модели двум программам требуется общий протокол для обмена данными. В вертикальной модели соседние уровни обмениваются данными с использованием интерфейсов прикладных программ API (Application Programming Interface).</p>

                    <img src="./images/Схема_взаимодействия.png">

                    <p>Перед подачей в сеть данные разбиваются на пакеты. Пакет (packet) - это единица информации, передаваемая между станциями сети. При отправке данных пакет проходит последовательно через все уровни программного обеспечения. На каждом уровне к пакету добавляется управляющая информация данного уровня (заголовок), которая необходима для успешной передачи данных по сети, как это показано на рис. 6 (тут картинка с пирамидкой), где Заг - заголовок пакета, а Кон - конец пакета.</p>
                    <p>На принимающей стороне пакет проходит через все уровни в обратном порядке. На каждом уровне протокол этого уровня читает информацию пакета, затем удаляет информацию, добавленную к пакету на этом же уровне отправляющей стороной, и передает пакет следующему уровню. Когда пакет дойдет до Прикладного уровня, вся управляющая информация будет удалена из пакета, и данные примут свой первоначальный вид.</p>

                    <img src="./images/Формирование_пакета.png">

                    <p>Каждый уровень модели выполняет свою функцию. Чем выше уровень, тем более сложную задачу он решает.</p>
                    <p>Отдельные уровни модели OSI удобно рассматривать как группы программ, предназначенных для выполнения конкретных функций. Один уровень, к примеру, отвечает за обеспечение преобразования данных из ASCII в EBCDIC и содержит программы, необходимые для выполнения этой задачи.</p>
                    <p>Каждый уровень обеспечивает сервис для вышестоящего уровня, запрашивая в свою очередь сервис у нижестоящего уровня. Верхние уровни запрашивают сервис почти одинаково: как правило, это требование маршрутизации каких-то данных из одной сети в другую. Практическая реализация принципов адресации данных возложена на нижние уровни. На рис. 7 приведено краткое описание функций всех уровней.</p>
                    <p>Рассматриваемая модель определяет взаимодействие открытых систем разных производителей в одной сети. Поэтому она выполняет для них координирующие действия по:</p>
                    <ul>
                    <li>взаимодействию прикладных процессов;</li>    
                    <li>формам представления данных;</li>
                    <li>единообразному хранению данных;</li>
                    <li>управлению сетевыми ресурсами;</li>
                    <li>безопасности данных и защите информации;</li>
                    <li>диагностике программ и технических средств.</li>  
                    </ul>

                    <img src="./images/Описание_всех_функций.png">

                    <h3>Общие замечания относительно OSI ISO</h3>
                    <ul>
                    <li>Избыточность и низкая функциональность верхних уровней.</li>
                    <li>Учет в стандартах всех теоретически возможных ситуаций.</li>
                    <li>Сложность спецификаций для реализации.</li>    
                    <li>Очень высокие требования к ресурсам сетевых компьютеров.</li>
                    </ul>
                    
                    <h2>Семь уровней эталонной модели OSI</h2>
                    <h3>1. Физический уровень (Передача битов данных по сети)</h3>
                    <p>Физический уровень преобразует биты в исходящие сигналы, передает сигналы и затем преобразует входящие сигналы в биты. Он определяет:</p>
                    <ul>
                    <li>характеристики сигналов;</li>
                    <li>среды передачи;</li>
                    <li>физическую топологию среды передачи;</li>
                    <li>механические и физические (электрические, оптические) спецификации среды передачи;</li>
                    <li>интерфейсы (разъемы) оборудования.</li>
                    </ul>
                    <p><b>Основные вопросы, решаемые на физическом уровне:</b></p>
                    <ul>
                    <li>какое напряжение должно использоваться для отображения единицы, а какое — для нуля;</li>
                    <li>сколько микросекунд длится бит;</li>
                    <li>может ли передача производиться одновременно в двух направлениях;</li>
                    <li>как устанавливается начальная связь и как прекращается, когда обе стороны закончили свои задачи;</li>
                    <li>из какого количества проводов должен состоять кабель и какова функция каждого провода.</li>
                    </ul>
                    <p>С этим уровнем связаны повторители, кабели, разъемы и т.д. Функции этого уровня реализуются на всех узлах сети (в компьютерах это либо сетевой адаптер, либо СОМ-порт).</p>

                    <h3>2. Канальный уровень (уровень передачи данных)</h3>
                    <p>Передаёт кадры (наборов битов) между двумя узлами сети, непосредственно связанными между собой.</p>
                    <p><b>Основная задача канального уровня - обеспечение доступа к разделяемой среде передачи и превращение ненадежной физической среды передачи в надежный канал связи.</b></p>
                    <p>С этой целью поток передаваемых данных разбивается на кадры (фреймы от англ. Frame) размером десятки байт - десятки килобайт. Каждый кадр снабжается служебным заголовком. Кадры передаются последовательно, их целостность проверяется контрольным суммированием.</p>
                    <p>Канальный уровень обеспечивает доставку кадров между любыми узлами сети, но только в пределах одной физической сети.</p>
                    <p>Канальный уровень распознает, те кадры, которые предназначены данному узлу сети и отбрасывает все остальные кадры.</p>
                    <p>Для идентификации компьютеров на канальном уровне используются аппаратные (физические) адреса (MAC – адреса)</p>
                    <p>На канальном уровне работают сетевые адаптеры, мосты, концентраторы, коммутаторы.</p>
                    <p>Подробнее: Передает кадры (frames) — наборы битов — между двумя узлами сети, непосредственно связанными между собой</p>
                    <p><b>Функции канального уровня:</b></p>
                    <ul>
                    <li>взаимодействие со средой передачи данных (протокол MAC);</li>
                    <li>надежная доставка;</li>
                    <li>управление потоком.</li>
                    </ul>
                    <p>Технологии: Ethernet (802.3), WiFi (802.11), Token Ring (802.5) и РРР.</p>
                    <p>В программировании этот уровень представляет драйвер сетевой платы, в операционных системах имеется программный интерфейс взаимодействия канального и сетевого уровней между собой.</p>
                    <p><b>Надежная доставка.</b> Когда протокол канального уровня предоставляет услугу по надежной доставке, <b>он гарантирует перемещение каждой дейтаграммы сетевого уровня по линии связи без ошибок.</b></p>
                    <p><b>Управление потоком.</b> Узлы на каждой стороне линии связи обладают буферами для хранения кадров ограниченного размера. Но кадры могут поступать на получающий узел быстрее, чем этот узел способен их обрабатывать. Без управления потоком буфер получателя может переполниться, а кадры будут потеряны.</p>
                    <p>Протокол канального уровня может обеспечить управление потоком <b>с целью предотвращения ситуации, когда передающий узел на одной стороне линии связи заваливает пакетами принимающий узел на другой стороне линии.</b></p>
                    <p><b>Обнаружение ошибок.</b> Принимающий узел может неверно посчитать, что значение бита в кадре равно нулю, в то время как передавалась единица, и наоборот. Подобные битовые ошибки вызываются ослаблением сигнала и электромагнитными помехами. Поскольку нет смысла передавать дальше дейтаграмму, содержащую ошибки, <b>многие протоколы канального уровня предоставляют услугу по обнаружению ошибок в кадре. Для этого передающий узел добавляет к кадру биты обнаружения ошибок (контрольную сумму), а получающий узел выполняет проверку контрольной суммы.</b></p>
                    <p>Служба обнаружения ошибок очень распространена среди протоколов канального уровня. Транспортный и сетевой уровни в Интернете также предоставляют ограниченную услугу по обнаружению ошибок. <b>На канальном уровне обнаружение ошибок сложнее и, как правило, реализуется аппаратно.</b></p>
                    <p><b>Исправление ошибок</b> выполняет расширенная служба обнаружения ошибок. Такая служба способна не только обнаружить ошибку в кадре, но также определить, в каком именно разряде она произошла, и таким образом исправить некоторые ошибки. Услуга по исправлению ошибок предоставляется некоторыми протоколами канального уровня (например, ATM), но, как правило, не для всего пакета, а только для его заголовка.</p>
                    <p><b>Дуплексная и полудуплексная передача.</b> При дуплексной передаче оба узла могут передавать друг другу пакеты одновременно. При полудуплексной передаче оба узла тоже могут передавать друг другу пакеты, но только поочередно.</p>

                    <h3>3. Сетевой</h3>
                    <p>Осуществляет управление <b>подсетью</b>, то есть совокупностью коммуникационного оборудования. Определяет маршруты следования данных. Соединяет разнородные сети.</p>
                    <p><b>Сетевой уровень важен, если клиенты подключены к разным сетям.</b> На этом уровне вводится понятие «сеть».</p>
                    <p>Сеть (подсеть) – совокупность сетевых узлов, соединенных канальным сегментом в соответствии с одной из сетевых технологии и использующих единый протокол канального уровня. Сети могут обладать произвольной структурой связей, в том числе и избыточными связями.</p>
                    <p><b>Сообщения сетевого уровня называются пакетами или датаграммами.</b></p>
                    <p>Внутри сети доставка пакета обеспечивается протоколом канального уровня с использованием МАС-адресов, а между сетями – протоколом сетевого уровня. При этом кроме физического адреса применяется понятие «номер сети». Номер сети должен быть уникальным, чтобы однозначно определять конкретную сеть. Для учета номеров сетей сетевой уровень использует для доставки пакетов другой класс адресов – логические или сетевые адреса.</p>
                    <p>Подсети соединяются маршрутизаторами.</p>
                    <p>Задача маршрутизации – основная задача сетевого уровня.</p>
                    <p>Другая задача - разбиение больших пакетов данных на фрагменты, которые помещаются в кадры канального уровня.</p>
                    <p>На этом уровне могут решаться задачи борьбы с «заторами», когда слишком много пакетов передается по одному и тому же маршруту.</p>
                    <p>На сетевом уровне также решаются задачи межсетевого взаимодействия, такие как преобразование адресов (например, с использованием протокола ARP для преобразования IP-адресов в MAC-адреса) и поддержка различных типов сетевых протоколов (IPv4, IPv6). Это позволяет объединять разнородные сети в единую глобальную инфраструктуру, обеспечивая связь между устройствами, расположенными в разных частях мира.</p>
                    <p>Протоколы сетевого уровня обычно реализуются программно. Кроме маршрутизаторов, сетевые протоколы реализованы в шлюзах.</p>
                    <p>Подробнее:  Отвечает за передачу дейтаграмм между удаленными компьютерами.</p>
                    <p><b>Функции</b> сетевого уровня:</p>
                    <ul>
                    <li>адресация компьютеров во всей глобальной сети (IP-адреса);</li>
                    <li><b>определение маршрутов пересылки пакетов</b> от источника к пункту назначения.</li>
                    </ul>
                    <p>Не обеспечивает надежность доставки (искажения, потери, изменение порядка следования).</p>
                    <p><b>Протоколы: IP (Internet Protocol), ARP, RARP, ICMP, DHCP</b></p>
                    <p>Сетевой уровень отвечает за передачу датаграмм между удаленными компьютерами. Задача - определение маршрутов пересылки пакетов от источника к пункту назначения.</p>
                    <p>Маршруты могут быть жестко заданы в виде таблиц и редко меняться, могут задаваться в начале каждого соединения ,могут быть динамическими, то есть вычисляться заново для каждого пакета с учетом текущей загруженности сети.</p>
                    <p>Если в подсети одновременно присутствует слишком большое количество пакетов, то они, образуют заторы в узких местах. Недопущение подобной закупорки также является задачей сетевого уровня.</p>
                    <p><b>При передаче пакета из одной сети в другую могут возникнуть проблемы:</b></p>
                    <ul>
                    <li>способ адресации, применяемый в одной сети, может отличаться от принятого в другой,</li>
                    <li>сеть может вообще отказаться принимать пакеты из-за того, что они слишком большого размера,</li>
                    <li>также могут различаться протоколы, и т. д.</li>
                    </ul>
                    <p>Именно сетевой уровень , решая эти проблемы, позволяет объединять разнородные сети.</p>
                    <p>Для преобразования IP-адресов (адресов сетевого уровня) в MAC-адреса (адреса канального уровня) в сетях TCP/IP используется протоколы ARP (англ. Address Resolution Protocol — протокол разрешения адресов) и RARP (англ. Reverse Address Resolution Protocol — обратный протокол преобразования адресов).</p>
                    
                    <h3>4. Транспортный</h3>
                    <p>Доставляет данные непосредственно от программы-отправителя к программе-получателю с определёнными гарантиями (на сохранность информации, порядок передачи сообщений и др.), не имеет дела с узлами сети.</p>
                    <p>Подробнее:  Осуществляет надежную доставку данных от отправителя к получателю.</p>
                    <p><b>Функции транспортного уровня:</b></p>
                    <ul>
                    <li>контроль ошибок: искажения пакетов, потери, изменение порядка следования, дублирование;</li>
                    <li>контроль потока данных;</li>
                    <li>сегментирует и повторно собирает данные в один поток;</li>
                    <li>обеспечивает совместное использование канала различными программами (каждой присваивается число – «номер порта»)</li>
                    </ul>
                    <p><b>Протоколы: TCP, UDP.</b></p>
                    <p><b>Обеспечивает передачу данных между любыми узлами сети с требуемым уровнем надежности.</b> Для этого на транспортном уровне имеются средства установления соединения, нумерации, буферизации и упорядочивания пакетов.</p>
                    <p><b>Определяет тип сервиса, предоставляемого сеансовому уровню</b> и, в конечном счете, пользователям сети. Наиболее популярной разновидностью транспортного соединения является защищенный от ошибок канал между двумя узлами, поставляющий сообщения или байты в том порядке, в каком они были отправлены. <b>Однако транспортный уровень может предоставлять и другие типы сервисов, например пересылку отдельных сообщений без гарантии соблюдения порядка их доставки</b> или одновременную отправку сообщения различным адресатам по принципу широковещания. Тип сервиса определяется при установке соединения.</p>
                    <p>Транспортный уровень является настоящим сквозным уровнем, то есть доставляющим сообщения от источника адресату. Другими словами, программа на машине-источнике поддерживает связь с подобной программой на другой машине при помощи заголовков сообщений и управляющих сообщений. На более низких уровнях для поддержки этого соединения устанавливаются соединения между всеми соседними машинами, через которые проходит маршрут сообщений.</p>
                    <p><b>Основная функция транспортного уровня — принять данные от сеансового уровня, разбить их при необходимости на небольшие части, называемые сегментами, передать их сетевому уровню и гарантировать, что эти части в правильном виде прибудут по назначению.</b></p>
                    
                    <h3>5. Сеансовый</h3>
                    <p>Организует <b>сеансы связи</b>, то есть долговременного взаимодействия между абонентами. Решает задачу синхронизации между абонентами. Позволяет двум сторонам поддерживать длительное взаимодействие (сеанс) по сети</p>
                    <p>Этот уровень реализуется программно.</p>
                    <p><b>Функции сеансового уровня:</b></p>
                    <ul>
                    <li>установление сеанcа;</li>
                    <li>поддержка/управление сеансом;</li>
                    <li>разрыв сеанса;</li>
                    <li>синхронизация передачи данных (можно помещать контрольные точки в поток данных и возвращаться назад к определенной точке).</li>
                    </ul>
                    
                    <h3>6. Уровень предоставления данных</h3>
                    <p>Занимается согласованием синтаксиса и семантики данных, передающихся по сети. И работает с формой представления передаваемой по сети информации, не меняя ее содержания.(представление данных, передаваемых между прикладными процессами, в нужной форме.)</p>
                    <p><b>Форматы представления данных зависит от конкретных аппаратных платформ и ОС. Для обеспечения сетевого взаимодействия разнотипных хостов необходимо решить задачу преобразования форматов данных – т.е. введения единого сетевого формата данных</b> (порядок байт, порядок битов в байте, различные методы кодировок логических значений, чисел, символов и т.д.).</p>
                    <p>Протокол: SSL стека TCP/IP.</p>
                    <p><b>Уровень отвечает за:</b></p>
                    <ul>
                    <li>преобразование форматов данных;</li>
                    <li>кодирование/декодирование данных.</li>
                    <li>шифрация и дешифрация данных для обеспечения секретности обмена данными</li>
                    <li>осуществляться сжатие/распаковка данных</li>
                    </ul>
                
                    <h3>7. Прикладной (Application layer)</h3>
                    <p>Предоставляет службы для специфических потребностей пользователей (электронная почта, передача файлов и др.)</p>
                    <p><b>Все эти услуги реализуются с помощью соответствующих протоколов прикладного уровня.</b></p>
                    <p>Подробнее:</p>
                    <p>Обеспечивает взаимодействие сети и пользователя.</p>
                    <p>Обеспечивает средства, непосредственно поддерживающие приложения,такие  как доступ к базе данных, доступ к разделяемым ресурсам, файлам и принтерам, доступ к информационным ресурсам глобальных сетей: электронную почту, сетевую печать (WWW, FTP, E-mail,), пересылку файлов через сеть.</p>
                    <p>Отвечает за передачу служебной информации, предоставляет приложениям информацию об ошибках и формирует запросы к уровню представления. Пример: HTTP, POP3, SMTP.</p>
                    <p><b>Протоколы:</b></p>
                    <ul>
                    <li>HTTP протокол передачи гипертекста составляющий основу технологии Всемирной Паутины. Когда браузер запрашивает веб-страницу, он передает ее имя(адрес) и рассчитывает на то, что сервер будет использовать HTTP. Сервер в ответ отсылает страницу.</li>
                    <li>POP3 (Post Office Protocol v.3) - протокол, используемый для получения сообщений с сервера электронной почты.</li>
                    <li>IMAP (Internet Message Access Protocol) - протокол, который используют для доступа к сообщениям, хранящимся на сервере электронной почты.</li>
                    <li>SMTP (Simple Mail Transfer Protocol) - текстовый протокол, используемый для отправки сообщений электронной почты между серверами. SMTP работает в архитектуре клиент-сервер. Клиент электронной почты отправителя, например, Microsoft Outlook или Apple Mail, использует SMTP для подключения к email-серверу и передачи сообщения на сервер получателя.</li>
                    <li>FTP(S) (File Transfer Protocol, протокол передачи файлов)</li>
                    </ul>
                    <p>Содержит набор популярных протоколов, необходимых пользователям. Одним из наиболее распространенных является протокол передачи гипертекста HTTP (HyperText Transfer Protocol), который составляет основу технологии Всемирной Паутины. Когда браузер запрашивает веб-страницу, он передает ее имя (адрес) и рассчитывает на то, что сервер будет использовать HTTP. Сервер в ответ отсылает страницу. Другие прикладные протоколы используются для передачи файлов, электронной почты, сетевых рассылок.</p>
                    <p>На этом уровне передаваемые данные называются сообщениями.</p>
                    <p>К числу наиболее распространенных протоколов верхних трех уровней относятся:</p>
                    <ul>
                    <li>FTP (File Transfer Protocol) протокол передачи файлов;</li>
                    <li>TFTP (Trivial File Transfer Protocol) простейший протокол пересылки файлов;</li>
                    <li>X.400 электронная почта;</li>
                    <li>Telnet работа с удаленным терминалом;</li>
                    <li>SMTP (SimpleMailTransferProtocol) простой протокол почтового обмена;</li>
                    <li>CMIP (CommonManagementInformationProtocol) общий протокол управления информацией;</li>
                    <li>SLIP (SerialLine IP) IP для последовательных линий. Протокол последовательной посимвольной передачи данных;</li>
                    <li>SNMP (SimpleNetworkManagementProtocol) простой протокол сетевого управления;</li>
                    <li>FTAM (FileTransfer, Access, andManagement) протокол передачи, доступа и управления файлами.</li>
                    </ul>

                `
            },
            topic5: {
                title: "Тема 5: Стек протокола TCP/IP",
                content: `
                    <h1>Тема 5: Стек протокола TCP/IP</h1>
                    <h2><b>Преимущества стека TCP/IP:</b> Почему он стал основой современных сетей</h2>
                    <p>лидирующая роль стека TCP/IP объясняется следующими его свойствами:</p>
                    <ul>
                    <li>Это наиболее завершенный стандартный и в то же время популярный стек сетевых протоколов, имеющий многолетнюю историю.</li>
                    <li>Почти все большие сети передают основную часть своего трафика с помощью протокола TCP/IP.</li>
                    <li>Это метод получения доступа к сети Internet.</li>
                    <li>Этот стек служит основой для создания intranet- корпоративной сети, использующей транспортные услуги Internet и гипертекстовую технологию WWW, разработанную в Internet.</li>
                    <li>Все современные операционные системы поддерживают стек TCP/IP.</li>
                    <li>Это гибкая технология для соединения разнородных систем как на уровне транспортных подсистем, так и на уровне прикладных сервисов.</li>
                    <li>Это устойчивая масштабируемая межплатформенная среда для приложений клиент-сервер.</li>
                    </ul>

                    <h2>Структура стека TCP/IP. Краткая характеристика протоколов</h2>
                    <p>Так как стек TCP/IP был разработан до появления модели взаимодействия открытых систем ISO/OSI, то, хотя он также имеет многоуровневую структуру, соответствие уровней стека TCP/IP уровням модели OSI достаточно условно.</p>
                    <p>Структура протоколов TCP/IP приведена на рисунке 2.1. Протоколы TCP/IP делятся на 4 уровня.</p>

                    <img src="./images/Стек_TCP_IP.png">

                    <p>Стек протоколов TCP/IP (Transmission Control Protocol/Internet Protocol, протокол управления передачей/протокол интернета) — сетевая модель, описывающая процесс передачи цифровых данных. Она названа по двум главным протоколам, <b>по этой модели построена глобальная сеть — интернет.</b></p>
                    <h2>Уровневая модель TCP/IP</h2>
                    <p>модель TCP/IP разделена на уровни, как и OSI, но отличие двух моделей в количестве уровней. А вот стоит ли говорить только о канальном или о канальном и физическом уровнях — нет единого мнения. В RFC они объединены, поскольку выполняют одну функцию. В статье мы придерживаемся официального интернет-стандарта RFC и не выделяем физический уровень в отдельный. Далее мы рассмотрим четыре уровня модели.</p>
                    <h3>Канальный уровень (link layer)</h3>
                    <p>Этот уровень в протоколах TCP/IP не регламентируется, но поддерживает все популярные стандарты физического и канального уровня: для локальных сетей это Ethernet, Token Ring, FDDI</p>
                    <p>Канальный уровень—описывает, как происходит обмен информацией на уровне сетевых устройств, определяет, как информация будет передаваться от одного устройства к другому. Информация здесь кодируется, делится на пакеты и отправляется по нужному каналу, т.е. среде передачи.</p>
                    <p>Этот уровень также вычисляет максимальное расстояние, на которое пакеты возможно передать, частоту сигнала, задержку ответа и т.д. Все это — физические свойства среды передачи информации. На канальном уровне самым распространенным протоколом является Ethernet, </p>
                    <h3>Межсетевой уровень (internet layer)</h3>
                    <p>Уровень занимается передачей пакетов с использованием различных транспортных технологий локальных сетей, территориальных сетей, линий специальной связи и т. п.</p>
                    <p>В качестве основного протокола сетевого уровня (в терминах модели OSI) в стеке используется протокол IP, который изначально проектировался как протокол передачи пакетов в составных сетях, состоящих из большого количества локальных сетей, объединенных как локальными, так и глобальными связями</p>
                    <p>Протокол IP является дейтаграммным протоколом, то есть он не гарантирует доставку пакетов до узла назначения, но старается это сделать.</p>
                    <p>К уровню межсетевого взаимодействия относятся и все протоколы, связанные с составлением и модификацией таблиц маршрутизации, такие как протоколы сбора маршрутной информации RIP (Routing Internet Protocol) и OSPF (Open Shortest Path First), а также протокол межсетевых управляющих сообщений ICMP . Последний протокол предназначен для обмена информацией об ошибках между маршрутизаторами сети и узлом - источником пакета. С помощью специальных пакетов ICMP сообщается о невозможности доставки пакета, о превышении времени жизни или продолжительности сборки пакета из фрагментов, об аномальных величинах параметров, об изменении маршрута пересылки и типа обслуживания, о состоянии системы и т.п.</p>
                    <p>Каждая индивидуальная сеть называется локальной, глобальная сеть интернет позволяет объединить все локальные сети. За объединение локальных сетей в глобальную отвечает сетевой уровень. Он регламентирует передачу информации по множеству локальных сетей, благодаря чему открывается возможность взаимодействия разных сетей.</p>
                    <p>Межсетевое взаимодействие — это основной принцип построения интернета.<b> Локальные сети по всему миру объединены в глобальную, а передачу данных между этими сетями осуществляют магистральные и пограничные маршрутизаторы.</b></p>
                    <h3>Маска подсети и IP-адреса</h3>
                    <p>Маска подсети помогает маршрутизатору понять, как и куда передавать пакет. Подсетью может являться любая сеть со своими протоколами. Маршрутизатор передает пакет напрямую, если получатель находится в той же подсети, что и отправитель. Если же подсети получателя и отправителя различаются, пакет передается на второй маршрутизатор, со второго на третий и далее по цепочке, пока не достигнет получателя.</p>
                    <p>Протокол интернета — IP (Internet Protocol) используется маршрутизатором, чтобы определить, к какой подсети принадлежит получатель. Свой уникальный IP-адрес есть у каждого сетевого устройства, при этом в глобальной сети не может существовать два устройства с одинаковым IP. Он имеет два подвида, первым был принят IPv4 (IP version 4, версии 4)</p>
                    <p>IPv4 предусматривает назначение каждому устройству 32-битного IP-адреса, что ограничивало максимально возможное число уникальных адресов 4 миллиардами (2³²). В более привычном для человека десятичном виде IPv4 выглядит как четыре блока (октета) чисел от 0 до 255, разделенных тремя точками. Первый октет IP-адреса означает его класс, классов всего 4: A, B, C, D.</p>
                    <p>В связи с быстрым ростом сети интернет остро вставала необходимость увеличения числа возможных IP-адресов. В 1998 впервые был описан IPv6 (IP version 6, версии 6), который использует 128-битные адреса, и позволяет назначить уникальные адреса для 2¹²⁸ устройств.</p>
                    <p>Такого количества IPv6 адресов будет достаточно, чтобы назначить уникальный адрес для каждого атома на планете.</p>
                    <p>IPv6 имеет вид восьми блоков по четыре шестнадцатеричных значения, а каждый блок разделяется двоеточием. IPv6 выглядит следующим образом:</p>
                    <i>2DAB:FFFF:0000:0000:01AA:00FF:DD72:2C4A.</i>
                    <p>IP предназначен для определения адресата и доставки ему информации, он предоставляет услугу для вышестоящих уровней, но не гарантирует целостность доставляемой информации.</p>
                    <p>IP способен инкапсулировать другие протоколы, предоставлять место, куда они могут быть встроены. Как было сказано выше, IP — это 32 бита информации, первые 8 бит в заголовке IP — поля для указания номера инкапсулируемого протокола. Для IPv4 первые 8 бит — поле «протокол», для IPv6 — поле «следующий заголовок».</p>
                    
                    <h3>Транспортный уровень (transport layer)</h3>
                    <p>На этом уровне функционируют протокол управления передачей TCP (Transmission Control Protocol) и протокол дейтаграмм пользователя UDP (User Datagram Protocol). Протокол TCP обеспечивает надежную передачу сообщений между удаленными прикладными процессами за счет образования виртуальных соединений. Протокол UDP обеспечивает передачу прикладных пакетов дейтаграммным способом, как и IP, и выполняет только функции связующего звена между сетевым протоколом и многочисленными прикладными процессами.</p>
                    <p>Протоколы TCP и UDP занимаются доставкой информации.</p>
                    <p>TCP (протокол управления передачей) — надежный, он обеспечивает передачу информации, проверяя дошла ли она, насколько полным является объем полученной информации и т.д. TCP дает возможность двум хостам производить обмен пакетами через установку соединения. Он предоставляет услугу для приложений, повторно запрашивает потерянную информацию, устраняет дублирующие пакеты, регулируя загруженность сети. TCP гарантирует получение и сборку информации у адресата в правильном порядке.</p>
                    <p>UDP (протокол пользовательских датаграмм) — ненадежный, он занимается передачей автономных датаграмм. UDP не гарантирует, что всех датаграммы дойдут до получателя. Датаграммы уже содержат всю необходимую информацию, чтобы дойти до получателя, но они все равно могут быть потеряны или доставлены в порядке отличном от порядка при отправлении.</p>
                    <p>UDP обычно не используется, если требуется надежная передача информации. Использовать UDP имеет смысл там, где потеря части информации не будет критичной для приложения, например, в видеоиграх или потоковой передаче видео. UDP необходим, когда делать повторный запрос сложно или неоправданно по каким-то причинам.</p>
                    <h3>Прикладной уровень</h3>
                    <p>В модели TCP/IP отсутствуют дополнительные промежуточные уровни (представления и сеансовый) в отличие от OSI. Функции форматирования и представления данных делегированы библиотекам и программным интерфейсам приложений (API) — своего рода базам знаний. Когда службы или приложения обращаются к библиотеке или API, те в ответ предоставляют набор действий, необходимых для выполнения задачи и полную инструкцию, каким образом эти действия нужно выполнять.</p>
                    <p>Протоколы прикладного уровня действуют для большинства приложений, они предоставляют услуги пользователю или обмениваются данными с «коллегами» с нижних уровней по уже установленным соединениям. Здесь для большинства приложений созданы свои протоколы, например HTTP для передачи гипертекста по сети, SMTP для передачи почты, FTP для передачи файлов, протокол назначения IP-адресов DHCP и прочие.</p>
                    <p><i>Зачем нужен порт и что означает термин сокет</i></p>
                    <p>Приложения прикладного уровня, общаются также с предыдущим, транспортным, но они видят его протоколы как «черные ящики». Для приема-передачи информации они могут работать с TCP или UDP, но понимают только конечный адрес в виде IP и порта, а не принцип их работы.</p>
                    <p>IP присваивается каждому компьютеру межсетевым уровнем, но обмен данными происходит не между компьютерами, а между приложениями, установленными на них. Чтобы получить доступ к тому или иному сетевому приложению недостаточно только IP, для идентификации приложений применяют порты. Комбинация IP-адреса и порта называется сокетом или гнездом (socket). Поэтому обмен информацией происходит между сокетами. Нередко слово сокет употребляют как синоним для хоста или пользователя, также сокетом называют гнездо подключения процессора.</p>
                    <p>Из привилегий у приложений на прикладном уровне можно выделить наличие собственных протоколов для обмена данными, а также фиксированный номер порта для обращения к сети. Администрация адресного пространства интернет (IANA), занимающаяся выделением диапазонов IP-адресов, отвечает еще за назначение сетевым приложениям портов.</p>
                    <p>Чтобы не запоминать числовые адреса интернет-серверов была создана DNS — служба доменных имен. DNS всегда слушает на 53 порту и преобразует буквенные имена сетевых доменов в числовые IP-адреса и наоборот. Служба DNS позволяет не запоминать IP — компьютер самостоятельно посылает запрос «какой IP у selectel.ru?» на 53 порт DNS-сервера, полученного от поставщика услуг интернет.</p>
                    <p>DNS-сервер дает компьютеру ответ «IP для selectel.ru — XXX.XXX.XXX.XXX». Затем, компьютер устанавливает соединение с веб-сервером полученного IP, который слушает на порту 80 для HTTP-протокола и на порту 443 для HTTPS. В браузере порт не отображается в адресной строке, а используется по умолчанию, но, по сути, полный адрес сайта Selectel выглядит вот так: https://selectel.ru:443.</p>
                    <p>Процесс, кодирования данных на прикладном уровне, передача их на транспортном, а затем на межсетевом и, наконец, на канальном уровне называется инкапсуляцией данных. Обратная передача битов информации по иерархии, с канального на прикладной уровни, называют декапсуляцией. Оба процесса осуществляются на компьютерах получателя и отправителя данных попеременно, это позволяет долго не удерживать одну сторону канала занятой, оставляя время на передачу информации другому компьютеру.</p>

                    <img src="./images/TCP_IP_Декапсуляция_Инкапсуляция.png">
                    
                    <h3>Стек протоколов, снова канальный уровень</h3>
                    <p>В сети, по стандарту Ethernet, устройства отправителя и адресата имеют определенный MAC-адрес — идентификатор «железа». MAC-адрес инкапсулируется в Ethernet вместе с типом передаваемых данных и самими данными. Фрагмент данных, составленных в соответствии с Ethernet называется фреймом или кадром (frame).</p>
                    <p>MAC-адрес каждого устройства уникален и двух «железок» с одинаковым адресом не должно существовать, хотя порой такое случается, что приводит к сетевым проблемам. Таким образом, при получении сетевой адаптер занимается извлечением полученной информации из кадра и ее дальнейшей обработкой.</p>
                    <p>После ознакомления с уровневой структурой модели становится понятно, что <b>информация не может передаваться между двумя компьютерами напрямую. Сначала кадры передаются на межсетевой уровень, где компьютеру отправителя и компьютеру получателя назначается уникальный IP. После чего, на транспортном уровне, информация передается в виде TCP-фреймов либо UDP-датаграмм.</b></p>
                    <p>На каждом этапе к уже имеющейся информации добавляется служебная информация, например, порт на прикладном уровне, необходимый для идентификации сетевого приложения. Добавление служебной информации к основной обеспечивают разные протоколы — сначала Ethernet, поверх него IP, еще выше TCP, над ним порт, означающий приложение с соответствующим  протоколом. Такая вложенность называется стеком, названным TCP/IP по двум главным протоколам модели.</p>
                `
            },

            topic6: {
                title: "Тема 6: Классификация вычислительных сетей",
                content: `
                    <h1>Тема 6: Классификация вычислительных сетей</h1>
                    <p>Не существует общепризнанной таксонометрии (классификации) сетей. Однако, известны общие критерии, которые позволяют выделить классы сетей. К таким критериям относятся:</p>
                    <ul>
                    <li>Технологии передачи данных.</li>
                    <li>Масштаб сети.</li>
                    </ul>
                    <h2>Существуют две основные технологии передачи данных:</h2>
                    <p>1) Вещание – это способ передачи, при котором информационное сообщение (сетевой пакет) достигает множества получателей. Иначе этот способ передачи называется «один ко многим».</p>
                
                    <p>2) Точка-точка – это способ передачи, при котором информационное сообщение (сетевой пакет) доставляется только одному получателю. Иначе этот способ передачи называется «один к одному».</p>
                    <p>Сети, использующие вещание, имеют единый канал данных для обмена информацией между всеми, подключенными к каналу хостами.</p>
                    <p>Поток пересылаемых данных разбивается на сетевые пакеты, каждый из которых имеет данные (Д) и заголовок (З).</p>
                    <p>Одним из полей заголовка является адрес получателя. В сети типа вещание сетевой пакет, отосланный хостом–отправителем, доступен всем другим хостам. Однако принимать и обрабатывать этот пакет должен только тот хост, адрес которого указан в заголовке. Такие сетевые пакеты называются уникастными (unicast). Некоторые сетевые пакеты предназначены всем хостам сети (широковещательные пакеты - broadcast) или для группы хостов (мультивещательные пакеты - multicast)</p>
                    <p>Сети типа вещание используется на малых территориях с ограниченным количеством хостов, подключенных к сети. К таким сетям относятся сети Ethernet.</p>
                    <p>Сети типа «вещание» подвержены перехвату информации, любой хост подключенный к такой сети, имеет потенциальную возможность перехватить любой сетевой пакет или сфабриковать ложный пакет. Существуют также более изощренные методы взлома, позволяющие перехватить любой сетевой поток пакетов, например, с целью их искажения.</p>
                    <p>Сети типа «точка-точка» соединяют каждую пару хостов индивидуальным каналом связи. Количество линий связи в такой сети выражается формулой N(N-1)/2</p>
                    <p>Количество каналов в таких сетях очень быстро возрастает с ростом N (уже для N=10 потребуется 45 каналов). Поэтому в реальных сетях каналы «точка–точка» обычно организуются с помощью выделения нескольких логических каналов (виртуальных каналов) внутри единой физической линии связи - сеть становится неполносвязной.</p>
                    <p>В неполносвязных сетях передача пакетов данных может выполняться по разным путям или маршрутам. Хосты такой сети, не имеющие прямых каналов связи, могут обмениваться данными с помощью пересылки сетевых пакетов промежуточными хостами сети. Поэтому в этих сетях возникает задача определения оптимального (наилучшего в каком-либо смысле) маршрута доставки сетевых пакетов. От эффективности решения этой задачи зависит эффективность (скорость, стоимость)  доставки данных, а так же загруженность и эффективность использования сети.</p>
                    <p>Сети типа «точка–точка» используются для охвата больших регионов (страна, республика, город). В таких сетях применяется специализированное сетевое оборудование – маршрутизаторы, шлюзы.</p>
                    <p>В сетях типа «точка–точка» пакет проходит по заданному маршруту, поэтому воздействовать на этот пакет могут только промежуточные узлы маршрута. Однако и в этих сетях существуют методы фальсификации маршрутов, с помощью которых хакер может проложить маршрут через собственный хост. Таким образом, создается угроза для фальсификации сетевых пакетов и в сетях «точка–точка».</p>
                    <p>Масштаб вычислительной сети характеризует ее протяженность и территориальную распределенность. Важным параметром сети является ее диаметр – протяженность линии связи, соединяющей наиболее удаленные друг от друга хосты сети.</p>
                    <p>По критерию масштаба различают:</p>
                    <p>1) Локальные вычислительные сети (LAN-Local Area Network). Размещаются в пределах комнаты, здания, группы рядом стоящих корпусов либо цехов предприятий.</p>
                    <p>Важнейшие характеристики LAN:</p>
                    <ul>
                    <li>диаметр сети ограничен максимально допустимой задержкой при передаче пакета по сети и составляет от 200 метров до нескольких километров;</li>
                    <li>способ передачи - вещание со скоростью 10 – 100 – 1000 Мбит, сетевая технология обычно Ethernet, либо Token Ring, либо FDDI.</li>
                    <li>топология сети (шинная, кольцевая, древовидная, сотовая, смешанная)</li>
                    </ul>
                    <p>2) Региональные сети (WAN - Wide Area Network), охватывают крупные географические области - город, страна, континент.</p>
                    <p>Важнейшие характеристики WAN:</p>
                    <ul>
                    <li>способ передачи - «точка–точка».</li>
                    <li>топология этих сетей обычно не предусматривает соединения индивидуальными каналами всех хостов сети и называется неполносвязной.</li>
                    </ul>
                    <p>Внутри WAN выделяют сети масштаба города (MAN - Metropolian Area Network). Их особенностью является передача как данных, так и мультимедийного трафика. Часто сети MAN объединяются с системами кабельного телевидения.</p>
                    <p>3) Глобальные сети (GAN – Global Area Network). Это сети масштаба всей планеты, объединяющие ресурсы множества подсетей и их хостов. Эти сети подобны сетям WAN, однако имеют значительно более сложную структуру. Примером GAN являются Internet.</p>
                    <p>Условное сопоставление масштабов сетей разных классов дает следующий рисунок.</p>
                    <h2>Глобальные сети</h2>
                    <p>Исторически первыми появились именно глобальные вычислительные сети. Впервые вычислительные сети появились в США в 60–х годах (ARPANET). Эти сети объединила Mainframe американских университетов. Для связи между городами использовались телефонные каналы и модемы. С помощью этого оборудования удаленные пользователи получали терминальный доступ к ЭВМ, а ЭВМ могли автоматически обменивается информацией. Скорость передачи в 1200 бит/с. считалось хорошим достижением. К концу 60-х годов она была доведена до 56 Кбит/с. В этих сетях были реализованы службы обмена файлами, e–mail, синхронизация баз данных.</p>
                    <p>На базе первых глобальных сетей родились, были реализованы и оформлены в виде стандарта основные идеи современных вычислительных сетей:</p>
                    <ul>
                    <li>многоуровневое построение коммуникационных протоколов;</li>
                    <li>технология коммутации пакетов;</li>
                    <li>маршрутизация сетевых пакетов.</li>
                    </ul>
                    <h2>Локальные сети</h2>
                    <p>В 70-х годах ХХ века были созданы миникомпьютеры и микро-ЭВМ. Доступность этих компьютеров позволяла приобретать их различным подразделениям и организациям. Для обеспечения обмена данными между этими компьютерами с целью повышения эффективности их работы разными фирмами были предложены различные методы и реализующие их аппаратно-программные средства. Были созданы различные блоки сопряжения компьютеров. Такие «фирменные» решения были способны обеспечить связь только отдельных типов компьютеров.</p>
                    <p>Для организации связи между различными типами компьютеров потребовалось разработать стандарты, строго формализующие процедуры обмена данными. Такие стандарты появились в 80-х годах XX века. Это такие сетевые технологии, такие как Ethernet, Token Ring, ArсNet, FDDI и др. Каждая сетевая технология определяет типы применяемых кабелей, характеристики активной сетевой аппаратуры, протоколы передачи данных. Стандартные сетевые технологии максимально упростили развертывание вычислительной сети – достаточно собрать оборудование в соответствии с требованиями стандарта, установить соответствующее программное обеспечение и сеть начинает работать.</p>
                    <p>На основе стандартных сетевых технологий широкое распространение получили локальные вычислительные сети. Уже в первых таких сетях  обеспечивалась скорость передачи данных 4-10 Мбит/Сек при протяженности сети в сотни метров.</p>
                    <h2>Современные тенденции</h2>
                    <p>Вычислительные сети постоянно развиваются. Появляются новые высокоскоростные сетевые технологии (Ethernet 10 Гбит/Сек, сети FrameRelay, сети ATM, беспроводные сети).</p>
                    <p>Сокращается разрыв по скорости обмена между глобальными и локальными сетями.</p>
                    <p>Усложняются локальные сети, в них появляется новое коммуникационное оборудование – коммуникаторы, шлюзы, маршрутизаторы.</p>
                    <p>Интеграция локальных и глобальных сетей привела к созданию особого вида сетей – корпоративных сетей, в которых работают технологии локальных сетей, несмотря на то, что офисы корпорации разнесены на тысячи километры.</p>
                    <p>В вычислительные сети возвращаются Mainframe-ы.</p>
                    <p>В современном мире  на вычислительные сети возлагается также задача передачи мультимедийной информации в режиме реального времени. Это предъявляет новые требования к вычислительным сетям: если данные требуют безошибочной передачи, то часть мультимедийных пакетов может быть потеряна. Если при передаче данных скорость не является существенной, то для мультимедиа-трафика этот параметр очень важен, так как позволяет обеспечить непрерывность потока данных, необходимую для качественного воспроизведения звука и изображения.</p>
                    <p>В перспективе ожидания слияние различных видов сетей: телевизионных, телефонных, информационных – в единую информационную сеть.</p>
                    <p></p>
                    
                `
            },
            topic7: {
                title: "Тема 7: Сетевая топология",
                content: `
                    <h1>Тема 7: Сетевая топология</h1>
                    <p><d>Топология вычислительные сети</d> – это схема, отображающая расположения узлов и их соединение с помощью коммуникационных подсетей. Понятие топологии относится, прежде всего, к локальным сетям. В глобальных сетях структура связей обычно скрыта от пользователей и не слишком важна, так как каждый сеанс связи может производиться по собственному пути.</p>
                    <p>Топология определяет требования к оборудованию, тип используемого кабеля, методы управления обменом, надежность работы, возможности расширения сети.</p>
                    <p>Топология сети отображается графом, вершины которого - активные узлы сети (хосты, коммутаторы, маршрутизаторы и т.д.), а ребра графа - это линии связи.</p>
                    <p>Различают логическую и физическую топологии сетей. Конфигурация физических связей отражает электрические соединения узлов сети и может отличаться от конфигурации логических связей. Логические связи отображают маршруты передачи данных между узлами сети.</p>
                    <p>Существует 4 основные сетевые топологии:</p>
                    <ul>
                    <li>шинная;</li>
                    <li>звездообразная (древовидная);</li>
                    <li>кольцевая;</li>
                    <li>сотовая (ячеистая);</li>
                    </ul>
                    <p>В реальных вычислительных сетях эти основные топологии могут смешиваться.</p>
                    <p>Для различения узлов сети могут применяться различные системы адресации. Однако в любой системе адресов каждый узел должен иметь уникальный адрес.</p>
                    <h2>Шинная топология.</h2>
                    <p>Все узлы подключаются к единой шине передачи данных. Шину образует одна или более пар электрических проводников, либо электромагнитные волны в беспроводных средах передачи данных. Сообщение, отсылаемое одним из хостов, доступно всем другим хостам подключенным к данной шине. Однако сообщение принимает только тот хост адрес, которого  указан в заголовке сообщения.</p>
                    <p>Сеть использует метод временного разделения общего канала. Это означает, что в каждый момент времени только один хост может передавать информацию. Поэтому рост числа узлов значительно влияет на производительность. При малом числе узлов канал будет простаивать, при большом – узлам придется долго ожидать освобождение канала. </p>
                    <p>Шинная топология применяется в небольших или временных сетях. Например, Ethernet 10Base–5 («толстый» Ethernet), 10Base-2 («тонкий» Ethernet).</p>
                    <p>Преимущества шинной топологии:</p>
                    <ol>
                    <li>надежна и проста в малых сетях;</li>
                    <li>быстро устанавливается;</li>
                    <li>требует минимального количества недорогого кабеля;</li>
                    <li>легко наращивается с помощью активных повторителей (Repeater).</li>
                    </ol>

                    <p>Недостатки шинной топологии:</p>
                    <ol>
                    <li>сложная диагностика – любое повреждение кабеля выводит из строя всю сеть;</li>
                    <li>каждое новое подключение требует прерывания в работе сети;</li>
                    <li>каждое новое подключение вносит затухание и искажение сигнала, снижает надежность;</li>
                    <li>с увеличением количества подключенных к сети хостов производительность сети снижается постепенно, однако при превышении критического числа наблюдается резкое падение производительности.</li>
                    </ol>
                    <h2>Звездообразная топология.</h2>
                    <p>Каждый узел подключается к отдельному центральному узлу или Hub-у.</p>
                    <p>Применяется в сетях с сосредоточенными узлами, когда каждый из них отстоит от центрального узла на расстояние, не превышающих фиксированную величину. Для наиболее распространенных сетей на основе Fast Ethernet 100Base-TX (витая пара) это значение составляет 100 метров. Каждый хост передает сообщение Hub-у, задачей которого является ретрансляции полученного сообщения для всех других хостов сети. Поэтому логической топологией такой сети является также шинная топология.</p>
                    <p>В качестве центрального узла в современных сетях часто используется Switch – коммутатор, который ретранслируют полученное сообщение только в направлении хоста, которому оно предназначено.</p>
                    <p>Наиболее часто используемый вид кабеля - четырехжильная витая пара.</p>
                    <p>Для расширения сети (подключение новых узлов) к одному из портов Hub-а могут подключаться другие Hub-ы. Hub-ы соединяются  между собой кросс-кабелем, разводка контактов которого отличается от кабеля, используемого для подключения хостов.</p>
                    <p>Преимущества:</p>
                    <ol>
                    <li>допускают простую модификацию сети и добавление новых абонентов;</li>
                    <li>hub-ы упрощают диагностику;</li>
                    <li>отказ одного узла не прерывает работу всей сети.</li>
                    </ol>
                    <p>Недостатки:</p>
                    <ol>
                    <li>повышенный расход кабеля;</li>
                    <li>необходимость дорогостоящих центральных узлов;</li>
                    <li>выход из строя центрального узла нарушает работу всей сети;</li>
                    <li>с увеличением количества подключенных к сети хостов производительность сети снижается постепенно, однако при превышении критического числа наблюдается резкое падение производительности.</li>
                    </ol>
                    <h2>Кольцевая топология.</h2>
                    <p>Каждый узел связан с парой соседних узлов, так что цепочка связей образует кольцо. На основе этой топологии строятся сети Token Ring. Кольцевая топология применяется в сетях, требующей гарантированной пропускной способности. Это достигается с помощью принципа эстафетной передачи. Вдоль кольца курсирует специальный сетевой пакет – маркер. Каждый узел, получив пустой маркер, может заполнить его своими данными. Когда маркер с данными достигает узла получателя, маркер освобождается и вновь может быть использован для пересылки данных. Маркер циркулирует по кольцу с частотой ~ 104 Оборотов/Сек в сети с диаметром кольца 200 Метров.</p>
                    <p>Скорость передачи в современных сетях Token Ring достигает 16 МБит/Сек. Для повышения производительности в кольце может циркулировать несколько маркеров. Применяются также сети с двойным кольцом, в которых маркеры циркулируют во встречных направлениях.</p>
                    <p>Преимущества:</p>
                    <ol>
                    <li>все узлы имеют равный доступ к каналу передачи данных и маркеру;</li>
                    <li>с ростом числа узлов происходит постепенное снижение производительности.</li>
                    </ol>
                    <p>Недостатки:</p>
                    <ol>
                    <li>отказ любого узла прерывает работу всей сети;</li>
                    <li>сложная диагностика;</li>
                    <li>реконфигурация (добавление/отключить) нарушает работу сети.</li>
                    </ol>
                    <h2>Сотовая топология.</h2>
                    <p>Характеризуется избыточными связями между абонентами. Полная сотовая топология используется редко, так как количество связей растет пропорционально квадрату от числа узлов и составляет N=n(n-1)/2, где n – число узлов. Другая проблема полносвязной топологии – организация N-1 портов у каждого узла.</p>
                    <p>Большинство сотовых сетей являются гибридными. Такие сети характеризуется небольшим количеством избыточных связей, их основное применение – глобальные сети.</p>
                    <p>Преимущества сотовой топологии:</p>
                    <ol>
                    <li>отказоустойчивость.</li>
                    </ol>
                    <p>Недостатки сотовой топологии:</p>
                    <ol>
                    <li>сложность сети;</li>
                    <li>высокая стоимость на поддержание избыточность каналов связи;</li>
                    <li>необходимость выбора маршрута для доставки сообщений.</li>
                    </ol>
                    <h2>Смешанная топология.</h2>
                    <p>Современные сети часто содержат элементы нескольких типовых топологий. Часто используется шинно-звездообразная топология.</p>
                    <p>Такой вариант применяется для создания локальных сетей для нескольких этажей, либо для соединения звездообразных сетей, охватывающих близко расположенные здания. Такая сеть имеет минимальную стоимость, высокую надежность, легко реконфигурируется, но имеет ограниченную производительность.</p>
                    <p>Другой вариант - звездообразно-кольцевая топология. Такие сети строятся с помощью специальных концентраторов реализующих кольцевые соединения. Электрические соединения образуют топологию «звезда», хотя электрическое соединение является «кольцо».</p>
                    <h2>Среда передачи данных.</h2>
                    <p>Важным элементом вычислительных сетей является среда передачи (англ. media) - это средства связи, по которым производится обмен информацией между компьютерами. Основная задача среды передачи - перенос данных в пространстве от хоста к хосту.</p>
                    <p>Среду перадачи данных образуют линии связи – физические средства передачи данных. В одной линии связи могут пролегать несколько каналов связи (виртуальных или логических каналов), например с помощью частотного или временного разделения каналов. Канал связи - это средство односторонней передачи данных.</p>
                    <p>Канал передачи данных - это средства двухстороннего обмена данными, которые включают в себя линии связи и аппаратуру передачи/приема данных. Каналы передачи данных связывают между собой источники и приемники информации.</p>
                    <p>Для построения компьютерных сетей применяются линии связи, использующие различную физическую среду:</p>
                    <ul>
                    <li>проводные линии связи без изолирующих и экранирующих оплеток;</li>
                    <li>кабельные, где для передачи сигналов используются кабели;</li>
                    <li>беспроводные, использующие для передачи сигналов электромагнитные волны.</li>
                    </ul>
                    <p>Физически среда передачи данных - это провод, кабель или пространство.
Большинство вычислительных сетей применяются только три основные группы кабелей:
</p>
                    <ul>
                    <li>коаксиальный кабель (coaxial cable);</li>
                    <li>кабель «витая пара» (twisted pair):</li>
                    <li>неэкранированная (unshielded twisted pair - UTP);</li>
                    <li>экранированная (shielded twisted pair -STP);</li>
                    <li>оптоволоконный кабель (fiber optic).</li>
                    </ul>
                    <p>Коаксиал содержит 2 проводника: центральный, который используется как сигнальный и оплетка, являющаяся экраном для защиты от электромагнитных помех.
Коаксиальный кабель классифицируют по размеру (RG) и волновому сопротивлению.
</p>
                    <p></p>
                    <p></p>
                    <p></p>
                
                `
            }
        };

        // Когда страница загружена
        document.addEventListener("DOMContentLoaded", () => {
            const links = document.querySelectorAll(".sidebar a");
            const contentDiv = document.getElementById("lecture-content");

            // Функция загрузки содержания
            function loadContent(topic) {
                if (topics[topic]) {
                    contentDiv.innerHTML = topics[topic].content;
                    if (topic === "topic1") {
                        // Добавляем обработчик для кнопки открытия popup
                        const openPopupBtn = document.getElementById("openPopup");
                        openPopupBtn.addEventListener("click", openModal);
                    }
                } else {
                    contentDiv.innerHTML = "<p>Содержимое не найдено.</p>";
                }
            }

            // Обработка клика по ссылке
            links.forEach(link => {
                link.addEventListener("click", (e) => {
                    e.preventDefault();
                    const topic = link.getAttribute("data-topic");
                    loadContent(topic);
                });
            });

            // Загрузить первую тему по умолчанию
            loadContent("topic1");

            // Работа с модальным окном
            const modal = document.getElementById("myModal");
            const closeModalBtn = document.getElementsByClassName("close")[0];

            function openModal() {
                modal.style.display = "block";
                initCanvas();
            }

            closeModalBtn.onclick = function() {
                modal.style.display = "none";
                cancelAnimationFrame(animationFrameId);
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                    cancelAnimationFrame(animationFrameId);
                }
            }

            // Функции для работы с canvas
            let animationFrameId;
            let startTime;
            const duration = 1000;
            let isDragging = false;
            let currentTarget = 'A';

            function initCanvas() {
                const canvas = document.getElementById('popupCanvas');
                const ctx = canvas.getContext('2d');
                const explanationDiv = document.getElementById('explanation');

                // Загружаем изображения
                const imgA = new Image();
                const imgB = new Image();
                const imgC = new Image();
                const imgV = new Image();

                imgA.src = './images/pc.jpg';
                imgB.src = './images/pc.jpg';
                imgC.src = './images/pc.jpg';
                imgV.src = './images/mail.jpg';

                // Начальные позиции элементов
                const elementA = { x: 50, y: 100, width: 50, height: 50 };
                const elementB = { x: 500, y: 100, width: 50, height: 50 };
                const elementC = { x: 500, y: 200, width: 50, height: 50 };
                const elementV = { 
                    x: elementA.x + (elementA.width - 50)/2, // Центр элемента A
                    y: elementA.y,
                    width: 50, 
                    height: 50 
                };

                function checkCollision(objV, objX) {
                    const vLeft = objV.x;
                    const vRight = objV.x + objV.width;
                    const vTop = objV.y - objV.height/2;
                    const vBottom = objV.y + objV.height/2;

                    const xLeft = objX.x;
                    const xRight = objX.x + objX.width;
                    const xTop = objX.y - objX.height/2;
                    const xBottom = objX.y + objX.height/2;

                    return !(vRight < xLeft || 
                             vLeft > xRight || 
                             vBottom < xTop || 
                             vTop > xBottom);
                }

                function updateExplanationText() {
                    let text = '';
                    if(checkCollision(elementV, elementA)) text = 'V пересекается с A';
                    else if(checkCollision(elementV, elementB)) text = 'V пересекается с B';
                    else if(checkCollision(elementV, elementC)) text = 'V пересекается с C';
                    explanationDiv.textContent = text;
                }

                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Рисуем линии
                    ctx.beginPath();
                    ctx.moveTo(elementA.x + elementA.width/2, elementA.y);
                    ctx.lineTo(elementB.x, elementB.y);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(elementB.x + elementB.width/2, elementB.y);
                    ctx.lineTo(elementC.x + elementC.width/2, elementC.y);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Рисуем элементы
                    ctx.drawImage(imgA, elementA.x, elementA.y - elementA.height/2, elementA.width, elementA.height);
                    ctx.drawImage(imgB, elementB.x, elementB.y - elementB.height/2, elementB.width, elementB.height);
                    ctx.drawImage(imgC, elementC.x, elementC.y - elementC.height/2, elementC.width, elementC.height);

                    // Рисуем элемент V
                    ctx.drawImage(imgV, elementV.x, elementV.y - elementV.height/2, elementV.width, elementV.height);

                    updateExplanationText();
                }

                function animateAB() {
                    const currentTime = performance.now();
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);

                    const startX = elementA.x + elementA.width;
                    const startY = elementA.y;
                    const endX = elementB.x;
                    const endY = elementB.y;

                    elementV.x = startX + (endX - startX) * progress - elementV.width/2;
                    elementV.y = startY + (endY - startY) * progress;

                    draw();

                    if(progress < 1) {
                        animationFrameId = requestAnimationFrame(animateAB);
                    } else {
                        currentTarget = 'B';
                        startTime = performance.now();
                        animateBC();
                    }
                }

                function animateBC() {
                    const currentTime = performance.now();
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);

                    const startX = elementB.x;
                    const startY = elementB.y;
                    const endY = elementC.y;

                    elementV.x = elementB.x;
                    elementV.y = startY + (endY - startY) * progress;

                    draw();

                    if(progress < 1) {
                        animationFrameId = requestAnimationFrame(animateBC);
                    } else {
                        currentTarget = 'C';
                    }
                }

                document.getElementById('moveButton').addEventListener('click', function() {
                    if(currentTarget === 'A') {
                        startTime = performance.now();
                        cancelAnimationFrame(animationFrameId);
                        animateAB();
                    } else if(currentTarget === 'B') {
                        startTime = performance.now();
                        cancelAnimationFrame(animationFrameId);
                        animateBC();
                    }
                    currentTarget = 'A';
                });

                let isDragging = false;

                canvas.addEventListener('mousedown', function(event) {
                    const mouseX = event.offsetX;
                    const mouseY = event.offsetY;

                    if(mouseX >= elementV.x && mouseX <= elementV.x + elementV.width &&
                        mouseY >= elementV.y - elementV.height/2 && mouseY <= elementV.y + elementV.height/2) {
                        isDragging = true;
                        currentTarget = 'dragging';
                    }
                });

                canvas.addEventListener('mousemove', function(event) {
                    if(isDragging) {
                        const mousePos = { x: event.offsetX, y: event.offsetY };

                        const segmentAB = {
                            start: { x: elementA.x + elementA.width/2, y: elementA.y },
                            end: { x: elementB.x, y: elementB.y }
                        };
                        const segmentBC = {
                            start: { x: elementB.x + elementB.width/2, y: elementB.y },
                            end: { x: elementC.x + elementC.width/2, y: elementC.y }
                        };

                        const closestAB = closestPointOnSegment(mousePos, segmentAB.start, segmentAB.end);
                        const closestBC = closestPointOnSegment(mousePos, segmentBC.start, segmentBC.end);

                        const distAB = Math.hypot(mousePos.x - closestAB.x, mousePos.y - closestAB.y);
                        const distBC = Math.hypot(mousePos.x - closestBC.x, mousePos.y - closestBC.y);

                        const targetPoint = distAB < distBC ? closestAB : closestBC;

                        elementV.x = targetPoint.x - elementV.width/2;
                        elementV.y = targetPoint.y;

                        draw();
                    }
                });

                canvas.addEventListener('mouseup', function() {
                    isDragging = false;
                    const originalX = elementA.x + (elementA.width - elementV.width)/2;
                    const originalY = elementA.y;
                    const distance = Math.hypot(elementV.x - originalX, elementV.y - originalY);
                    if(distance < 10) {
                        elementV.x = originalX;
                        elementV.y = originalY;
                        currentTarget = 'A';
                        draw();
                    } else if(elementV.y === elementB.y) {
                        currentTarget = 'B';
                    }
                });

                canvas.addEventListener('mouseleave', () => isDragging = false);

                // Функция для поиска ближайшей точки на сегменте
                function closestPointOnSegment(p, p0, p1) {
                    const dx = p1.x - p0.x;
                    const dy = p1.y - p0.y;
                    const t = ((p.x - p0.x) * dx + (p.y - p0.y) * dy) / (dx * dx + dy * dy || 1);
                    const tClamped = Math.max(0, Math.min(1, t));
                    return {
                        x: p0.x + dx * tClamped,
                        y: p0.y + dy * tClamped
                    };
                }

                // Загрузка изображений
                let imagesLoaded = 0;
                const totalImages = 4;
                function imageLoaded() {
                    imagesLoaded++;
                    if(imagesLoaded === totalImages) draw();
                }
                imgA.onload = imageLoaded;
                imgB.onload = imageLoaded;
                imgC.onload = imageLoaded;
                imgV.onload = imageLoaded;
            }
        });
    </script>
</body>
</html>
